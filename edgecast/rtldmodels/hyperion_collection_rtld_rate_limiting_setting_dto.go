// Code generated by go-swagger; DO NOT EDIT.

package rtldmodels

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// HyperionCollectionRtldRateLimitingSettingDto hyperion collection rtld rate limiting setting dto
//
// swagger:model HyperionCollection[RtldRateLimitingSettingDto]
type HyperionCollectionRtldRateLimitingSettingDto struct {

	// at id
	AtID string `json:"@id,omitempty"`

	// at type
	AtType *string `json:"@type,omitempty"`

	// items
	Items []*HyperionCollectionRtldRateLimitingSettingDtoItemsItems0 `json:"items"`

	// total items
	TotalItems int32 `json:"total_items,omitempty"`
}

// Validate validates this hyperion collection rtld rate limiting setting dto
func (m *HyperionCollectionRtldRateLimitingSettingDto) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateItems(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *HyperionCollectionRtldRateLimitingSettingDto) validateItems(formats strfmt.Registry) error {
	if swag.IsZero(m.Items) { // not required
		return nil
	}

	for i := 0; i < len(m.Items); i++ {
		if swag.IsZero(m.Items[i]) { // not required
			continue
		}

		if m.Items[i] != nil {
			if err := m.Items[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("items" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this hyperion collection rtld rate limiting setting dto based on the context it is used
func (m *HyperionCollectionRtldRateLimitingSettingDto) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *HyperionCollectionRtldRateLimitingSettingDto) contextValidateItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Items); i++ {

		if m.Items[i] != nil {
			if err := m.Items[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("items" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *HyperionCollectionRtldRateLimitingSettingDto) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *HyperionCollectionRtldRateLimitingSettingDto) UnmarshalBinary(b []byte) error {
	var res HyperionCollectionRtldRateLimitingSettingDto
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// HyperionCollectionRtldRateLimitingSettingDtoItemsItems0 hyperion collection rtld rate limiting setting dto items items0
//
// swagger:model HyperionCollectionRtldRateLimitingSettingDtoItemsItems0
type HyperionCollectionRtldRateLimitingSettingDtoItemsItems0 struct {
	BaseRtldSettingDto

	// client ip filter
	ClientIPFilter []string `json:"client_ip_filter"`

	// country code filter
	CountryCodeFilter []string `json:"country_code_filter"`

	// excluded client ip filter
	ExcludedClientIPFilter []string `json:"excluded_client_ip_filter"`

	// excluded country code filter
	ExcludedCountryCodeFilter []string `json:"excluded_country_code_filter"`

	// excluded limit action type filter
	ExcludedLimitActionTypeFilter []string `json:"excluded_limit_action_type_filter"`

	// excluded method filter
	ExcludedMethodFilter []string `json:"excluded_method_filter"`

	// limit action type filter
	LimitActionTypeFilter []string `json:"limit_action_type_filter"`

	// limit id filter
	LimitIDFilter []string `json:"limit_id_filter"`

	// method filter
	MethodFilter []string `json:"method_filter"`

	// scope name filter
	ScopeNameFilter []string `json:"scope_name_filter"`

	// url regexp filter
	URLRegexpFilter string `json:"url_regexp_filter,omitempty"`

	// user agent regexp filter
	UserAgentRegexpFilter string `json:"user_agent_regexp_filter,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *HyperionCollectionRtldRateLimitingSettingDtoItemsItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 BaseRtldSettingDto
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.BaseRtldSettingDto = aO0

	// AO1
	var dataAO1 struct {
		ClientIPFilter []string `json:"client_ip_filter"`

		CountryCodeFilter []string `json:"country_code_filter"`

		ExcludedClientIPFilter []string `json:"excluded_client_ip_filter"`

		ExcludedCountryCodeFilter []string `json:"excluded_country_code_filter"`

		ExcludedLimitActionTypeFilter []string `json:"excluded_limit_action_type_filter"`

		ExcludedMethodFilter []string `json:"excluded_method_filter"`

		LimitActionTypeFilter []string `json:"limit_action_type_filter"`

		LimitIDFilter []string `json:"limit_id_filter"`

		MethodFilter []string `json:"method_filter"`

		ScopeNameFilter []string `json:"scope_name_filter"`

		URLRegexpFilter string `json:"url_regexp_filter,omitempty"`

		UserAgentRegexpFilter string `json:"user_agent_regexp_filter,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.ClientIPFilter = dataAO1.ClientIPFilter

	m.CountryCodeFilter = dataAO1.CountryCodeFilter

	m.ExcludedClientIPFilter = dataAO1.ExcludedClientIPFilter

	m.ExcludedCountryCodeFilter = dataAO1.ExcludedCountryCodeFilter

	m.ExcludedLimitActionTypeFilter = dataAO1.ExcludedLimitActionTypeFilter

	m.ExcludedMethodFilter = dataAO1.ExcludedMethodFilter

	m.LimitActionTypeFilter = dataAO1.LimitActionTypeFilter

	m.LimitIDFilter = dataAO1.LimitIDFilter

	m.MethodFilter = dataAO1.MethodFilter

	m.ScopeNameFilter = dataAO1.ScopeNameFilter

	m.URLRegexpFilter = dataAO1.URLRegexpFilter

	m.UserAgentRegexpFilter = dataAO1.UserAgentRegexpFilter

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m HyperionCollectionRtldRateLimitingSettingDtoItemsItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.BaseRtldSettingDto)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		ClientIPFilter []string `json:"client_ip_filter"`

		CountryCodeFilter []string `json:"country_code_filter"`

		ExcludedClientIPFilter []string `json:"excluded_client_ip_filter"`

		ExcludedCountryCodeFilter []string `json:"excluded_country_code_filter"`

		ExcludedLimitActionTypeFilter []string `json:"excluded_limit_action_type_filter"`

		ExcludedMethodFilter []string `json:"excluded_method_filter"`

		LimitActionTypeFilter []string `json:"limit_action_type_filter"`

		LimitIDFilter []string `json:"limit_id_filter"`

		MethodFilter []string `json:"method_filter"`

		ScopeNameFilter []string `json:"scope_name_filter"`

		URLRegexpFilter string `json:"url_regexp_filter,omitempty"`

		UserAgentRegexpFilter string `json:"user_agent_regexp_filter,omitempty"`
	}

	dataAO1.ClientIPFilter = m.ClientIPFilter

	dataAO1.CountryCodeFilter = m.CountryCodeFilter

	dataAO1.ExcludedClientIPFilter = m.ExcludedClientIPFilter

	dataAO1.ExcludedCountryCodeFilter = m.ExcludedCountryCodeFilter

	dataAO1.ExcludedLimitActionTypeFilter = m.ExcludedLimitActionTypeFilter

	dataAO1.ExcludedMethodFilter = m.ExcludedMethodFilter

	dataAO1.LimitActionTypeFilter = m.LimitActionTypeFilter

	dataAO1.LimitIDFilter = m.LimitIDFilter

	dataAO1.MethodFilter = m.MethodFilter

	dataAO1.ScopeNameFilter = m.ScopeNameFilter

	dataAO1.URLRegexpFilter = m.URLRegexpFilter

	dataAO1.UserAgentRegexpFilter = m.UserAgentRegexpFilter

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this hyperion collection rtld rate limiting setting dto items items0
func (m *HyperionCollectionRtldRateLimitingSettingDtoItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with BaseRtldSettingDto
	if err := m.BaseRtldSettingDto.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// ContextValidate validate this hyperion collection rtld rate limiting setting dto items items0 based on the context it is used
func (m *HyperionCollectionRtldRateLimitingSettingDtoItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with BaseRtldSettingDto
	if err := m.BaseRtldSettingDto.ContextValidate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *HyperionCollectionRtldRateLimitingSettingDtoItemsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *HyperionCollectionRtldRateLimitingSettingDtoItemsItems0) UnmarshalBinary(b []byte) error {
	var res HyperionCollectionRtldRateLimitingSettingDtoItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
